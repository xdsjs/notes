> 2017年2月5日
>
> 本文章仅为《C++ Primer 中文版》读书笔记，所有版权归原书所有。

> 复合类型是指基于其他类型定义的类型

### 引用

引用为对象起了另外一个名字。通过将声明符携程&d的形式来定义引用类型，其中d是声明的变量名。

```c++
int ival = 1024;
int &refVal = ival;  // refVal指向ival(是ival的另一个名字)
int &refVal2;        // 错误，引用必须被初始化
```

- 引用必须初始化
- 引用即别名，不同于对象
- 定义一个饮用后，对其所有的操作都是在与之绑定的对象上进行的
- 一条语句中可以定义多个引用，每个引用标识符必须以符号&开头
- 引用类型要和与之绑定的对象的类型严格匹配

```c++
int &refVal3 = refVal;  // refVal3绑定到了与refVal绑定的对象上，即绑定到了ival上
int i = refVal;         // 利用与refVal绑定的对象的值初始化变量，i被赋值为ival的值
```

### 指针

指针是指向另一种类型的符合类型。

##### 与引用的不同

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在其生命周期内可以指向几个不同的对象
- 指针无须在定义时赋初值。与其他内置类型相同，在块作用域内的指针如果没有初始化，则将拥有一个不确定的值
- 两者相同点则是都对其他对象的间接访问

##### 用法

- 指针类型声明形式为*d，其中d为变量名
- 指针存放某个对象的地址，要想获取改地址，使用取地址符（符号&）
- 除个别例外，指针类型要与它所指向的类型严格匹配

```c++
int *ip1, *ip2;  // ip1和ip2都是指向int型对象的指针
double db, *dp2; // dp2是指向double对象的指针，dp是double型对象

int ival = 42;
int *p = &ival;  // p存放变量ival的地址，或者说p是指向变量ival的指针
```

##### 指针值

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况之外的其他值

##### 解引用符（操作符*）

如果指针指向了一个对象，可以使用解引用符*来访问该对象。对指针解引用会得到所指的对象。

```c++
int ival = 42;
int *p = &ival;  // p是指向变量ival的指针
cout << *p;      // 由符号*得到指针p所指的对象，输出42
```

##### 空指针

空指针不指向任何对象，因此在试图使用一个指针前应检查其是否为空。

```c++
/*生成空指针的几种方法*/

// 方法1 C++11标准中规定的，也是目前最推荐的
int *p1 = nullptr;   // 等价于int *p1 = 0;
// 方法2 注意不能将int型变量赋给指针。即使这个int型变量的值为0
int *p2 = 0;         // 直接将p2初始化为字面值常量0
// 方法3 首先需要#include cstdlib
int *p3 = NULL;      // 等价于int *p3 = 0;
```

**注意：尽量初始化所有的指针，以此来降低指针操作的危害**

##### 特殊的指针操作

只要指针由一个合法值，就能将它用在条件表达式中。

```c++
int ival = 1024;
int *pi = 0;       // pi合法，是一个空指针
int *pi2 = &ival;  // pi2是一个合法的指针，存放着ival的地址
if(pi)             // pi的值为0，因此条件的值是false
  // ...
if(pi2)            // pi2指向ival，值不为0，因此条件的值为true
  // ...
```

##### void*指针（特殊类型的指针）

- 可以存放任意类型对象的地址
- 不能直接操作void*指针所指的对象，因为并不知道这个对象到底是什么类型

